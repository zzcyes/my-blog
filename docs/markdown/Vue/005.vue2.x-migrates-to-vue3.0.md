# 005.vue2.x-migrates-to-vue3.0

## Notable New Features

### [Composition API](https://v3.vuejs.org/guide/composition-api-introduction.html#why-composition-api)

### [Teleport](https://v3.vuejs.org/guide/teleport.html)

Teleport（以前称为 Portal）是将子节点渲染到 DOM 谱系之外的 DOM 节点中的安全通道，例如弹出窗口甚至是模式。

```html
<body>
  <div id="app" style="position: relative;">
    <h3>Tooltips with Vue 3 Teleport</h3>
    <div>
      <modal-button></modal-button>
    </div>
  </div>
</body>
```

```css
.modal {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.modal div {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-color: white;
  width: 300px;
  height: 300px;
  padding: 5px;
}
```

```javascript
const app = Vue.createApp({});

app.component('modal-button', {
  template: `
    <button @click="modalOpen = true">
        Open full screen modal! (With teleport!)
    </button>

    <teleport to="body">
      <div v-if="modalOpen" class="modal">
        <div>
          I'm a teleported modal!
          (My parent is "body")
          <button @click="modalOpen = false">
            Close
          </button>
        </div>
      </div>
    </teleport>
  `,
  data() {
    return {
      modalOpen: false,
    };
  },
});
```

- 在 Vue components 中使用

```javascript
const app = Vue.createApp({
  template: `
    <h1>Root instance</h1>
    <parent-component />
  `,
});

app.component('parent-component', {
  template: `
    <h2>This is a parent component</h2>
    <teleport to="#endofbody">
      <child-component name="John" />
    </teleport>
  `,
});

app.component('child-component', {
  props: ['name'],
  template: `
    <div>Hello, {{ name }}</div>
  `,
});
```

In this case, even when child-component is rendered in the different place, it will remain a child of parent-component and will receive a name prop from it.

This also means that injections from a parent component work as expected, and that the child component will be nested below the parent component in the Vue Devtools, instead of being placed where the actual content moved to.

- 对同一个目标使用多次`teleport`

多个`<teleport>`组件可以将它们的内容挂载到相同的目标元素,这个顺序将是一个简单的附加—稍后的挂载将位于目标元素中较早的挂载之后。

```html
<teleport to="#modals">
  <div>A</div>
</teleport>
<teleport to="#modals">
  <div>B</div>
</teleport>

<!-- result-->
<div id="modals">
  <div>A</div>
  <div>B</div>
</div>
```

- to 必须是一个有效的查询选择器，或一个 HTMLElement(如果在浏览器环境中使用)。指定<teleport>内容将在其中移动的目标元素

```html
<!-- ok -->
<teleport to="#some-id" />
<teleport to=".some-class" />
<teleport to="[data-teleport]" />

<!-- Wrong -->
<teleport to="h1" />
<teleport to="some-string" />
```

- disabled 可以用来禁用`<teleport>`功能，这意味着它的插槽内容不会移动到任何地方，而是呈现在您在周围父组件中指定`<teleport>`的地方。

```html
<teleport to="#popup" :disabled="displayVideoInline">
  <video src="./my-movie.mp4">
</teleport>
```

tips: 这将移动实际的 `DOM` 节点，而不是销毁和重新创建，并且还将保持任何组件实例是活动的。所有有状态 `HTML` 元素(比如一个正在播放的视频)将保持它们的状态。

### [Fragments](https://v3.vuejs.org/guide/migration/fragments.html)

- vue2.x

```html
<!-- Layout.vue -->
<template>
  <div>
    <header>...</header>
    <main>...</main>
    <footer>...</footer>
  </div>
</template>
```

- vue3.0

In 3.x, components now can have multiple root nodes! However, this does require developers to explicitly define where attributes should be distributed.

```html
<template>
  <header>...</header>
  <main v-bind="$attrs">...</main>
  <footer>...</footer>
</template>
```

### [Emits Component Option](https://v3.vuejs.org/guide/component-custom-events.html)

- Event Names

```javascript
this.$emit('myEvent');
```

```html
<!-- Won't work -->
<my-component @my-event="doSomething"></my-component>
```

由于事件名称永远不会在 `JavaScript` 中用作变量或属性名称，因此没有理由使用 `camelCase` 或 `PascalCase`。另外，`v-on` 内模板 `DOM` 事件监听器会自动转化成小写（由于 `HTML` 的不区分大小写），因此`@myEvent` 将成为 `@myevent` 让 `myEvent` 不可能听。

对事件名称使用 `kebab-case`。

- Defining Custom Events

```javascript
app.component('custom-form', {
  emits: ['in-focus', 'submit'],
});
```

如果 `click` 在 `emits` 选项中定义了本地事件（例如），它将被组件中的事件覆盖，而不是被视为本地侦听器。

- Validate Emitted Events

```javascript
app.component('custom-form', {
  emits: {
    // No validation
    click: null,

    // Validate submit event
    submit: ({ email, password }) => {
      if (email && password) {
        return true;
      } else {
        console.warn('Invalid submit event payload!');
        return false;
      }
    },
  },
  methods: {
    submitForm() {
      this.$emit('submit', { email, password });
    },
  },
});
```

- v-model arguments

```html
<my-component v-model:foo="bar"></my-component>
```

```javascript
const app = Vue.createApp({});

app.component('my-component', {
  props: {
    foo: String,
  },
  template: `
    <input
      type="text"
      :value="foo"
      @input="$emit('update:foo', $event.target.value)">
  `,
});
```

- Multiple v-model bindings

```html
<user-name
  v-model:first-name="firstName"
  v-model:last-name="lastName"
></user-name>
```

```javascript
const app = Vue.createApp({});

app.component('user-name', {
  props: {
    firstName: String,
    lastName: String,
  },
  template: `
    <input
      type="text"
      :value="firstName"
      @input="$emit('update:firstName', $event.target.value)">

    <input
      type="text"
      :value="lastName"
      @input="$emit('update:lastName', $event.target.value)">
  `,
});
```

- Handling v-model modifiers

```html
<my-component v-model.capitalize="bar"></my-component>
```

```javascript
app.component('my-component', {
  props: {
    modelValue: String,
    modelModifiers: {
      default: () => ({}),
    },
  },
  template: `
    <input type="text"
      :value="modelValue"
      @input="$emit('update:modelValue', $event.target.value)">
  `,
  created() {
    console.log(this.modelModifiers); // { capitalize: true }
  },
});
```

现在我们已经设置好道具，我们可以检查`modelModifiers`对象键并编写一个处理程序来更改发射的值。在下面的代码中，无论何时`<input />`元素触发`input`事件，我们都将大写字符串。

```html
<div id="app">
  <my-component v-model.capitalize="myText"></my-component>
  {{ myText }}
</div>
```

```javascript
const app = Vue.createApp({
  data() {
    return {
      myText: '',
    };
  },
});

app.component('my-component', {
  props: {
    modelValue: String,
    modelModifiers: {
      default: () => ({}),
    },
  },
  methods: {
    emitValue(e) {
      let value = e.target.value;
      if (this.modelModifiers.capitalize) {
        value = value.charAt(0).toUpperCase() + value.slice(1);
      }
      this.$emit('update:modelValue', value);
    },
  },
  template: `<input
    type="text"
    :value="modelValue"
    @input="emitValue">`,
});

app.mount('#app');
```

对于`v-model`带有参数的绑定，生成的 prop 名称将为`arg + "Modifiers"`：

```html
<my-component v-model:foo.capitalize="bar"></my-component>
```

```javascript
app.component('my-component', {
  props: ['foo', 'fooModifiers'],
  template: `
    <input type="text"
      :value="foo"
      @input="$emit('update:foo', $event.target.value)">
  `,
  created() {
    console.log(this.fooModifiers); // { capitalize: true }
  },
});
```

### [createRenderer API 从 @vue/runtime-core 创建自定义渲染器](https://github.com/vuejs/vue-next/tree/master/packages/runtime-core)

@vue/runtime-core

> This package is published only for typing and building custom renderers. It is NOT meant to be used in applications.

For full exposed APIs, see `src/index.ts`. You can also run `yarn build runtime-core --types` from repo root, which will generate an API report at `temp/runtime-core.api.md`.

Building a Custom Renderer

```javascript
import { createRenderer } from '@vue/runtime-core';

const { render, createApp } = createRenderer({
  patchProp,
  insert,
  remove,
  createElement,
  // ...
});

// `render` is the low-level API
// `createApp` returns an app instance with configurable context shared
// by the entire app tree.
export { render, createApp };

export * from '@vue/runtime-core';
```

See `@vue/runtime-dom` for how a DOM-targeting renderer is implemented.

### [单文件组件 `<style scoped>` 现在可以包含全局规则或只针对插槽内容的规则](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0023-scoped-styles-changes.md)

- `>>>` and `/deep/` support are deprecated.

- ::v-deep usage as a combinator is deprecated:

```
/_ DEPRECATED _/
::v-deep .bar {}
```

Instead, use it as a pseudo element that accepts another selector as argument:

```
::v-deep(.bar) {}
```

The above compiles to:

```
[v-data-xxxxxxx] .bar {}
```

- Slot content passed in from the parent no longer gets affected by child scoped styles by default. Instead, the child now needs to use the new ::v-slotted() pseudo element to specifically target slot content:

```
::v-slotted(.foo) {}
```

Compiles to:

```
.foo[v-data-xxxxxxx-s] {}
```

Notice the -s postfix which makes it target slot content only.

- New pseudo element ::v-global() can be used to apply global rules inside a <style scoped> block:

```
::v-global(.foo) {}
```

Compiles to:

```
.foo {}
```

The test cases of `@vue/compiler-sfc` can be used as a reference for the compilation transform details.
